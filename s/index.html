<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Teddy bear runner game" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>teddy run | ksr</title>
    <link rel="stylesheet" href="../styles.css?v=1" />
    <style>
      body {
        overflow: hidden;
      }

      .game-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #gameCanvas {
        display: block;
        max-width: 100%;
        max-height: 100%;
        border: 1px solid rgba(0, 255, 65, 0.18);
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
        background: #000000;
      }

      .game-ui {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .back-link {
        color: rgba(255, 255, 255, 0.75);
        text-decoration: none;
        font-size: 13px;
        letter-spacing: 1px;
        padding: 8px 14px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
        transition: all 0.2s;
      }

      .back-link:hover {
        color: rgba(255, 255, 255, 0.95);
        border-color: rgba(0, 255, 65, 0.3);
        box-shadow: 0 0 15px rgba(0, 255, 65, 0.15);
      }

      .score {
        color: rgba(255, 255, 255, 0.9);
        font-family: "Courier New", Courier, monospace;
        font-size: 18px;
        font-weight: 700;
        text-shadow:
          0 0 10px rgba(255, 255, 255, 0.4),
          0 0 20px rgba(255, 255, 255, 0.3);
        padding: 8px 14px;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(0, 255, 65, 0.18);
        border-radius: 8px;
      }

      .highscores {
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .highscore-item {
        color: rgba(255, 255, 255, 0.7);
        font-family: "Courier New", Courier, monospace;
        font-size: 12px;
        padding: 4px 10px;
        background: rgba(0, 0, 0, 0.25);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(0, 255, 65, 0.12);
        border-radius: 6px;
      }

      .highscore-item:first-child {
        color: rgba(255, 255, 255, 0.85);
        border-color: rgba(0, 255, 65, 0.25);
      }

      .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 20;
        text-align: center;
        display: none;
      }

      .game-over.active {
        display: block;
      }

      .game-over-box {
        background:
          radial-gradient(400px 200px at 30% 20%, rgba(0, 255, 65, 0.08), transparent 60%),
          radial-gradient(400px 200px at 70% 40%, rgba(0, 204, 51, 0.06), transparent 60%),
          rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(0, 255, 65, 0.18);
        border-radius: 20px;
        padding: 40px;
        box-shadow:
          0 0 60px rgba(0, 0, 0, 0.8),
          inset 0 0 0 1px rgba(0, 255, 65, 0.06);
      }

      .game-over-title {
        font-size: 32px;
        font-weight: 900;
        letter-spacing: 3px;
        color: rgba(255, 255, 255, 0.95);
        text-shadow:
          0 0 18px rgba(255, 255, 255, 0.35),
          0 0 22px rgba(255, 255, 255, 0.25);
        margin-bottom: 20px;
        text-transform: lowercase;
      }

      .game-over-score {
        font-family: "Courier New", Courier, monospace;
        font-size: 18px;
        color: rgba(255, 255, 255, 0.92);
        margin-bottom: 24px;
        text-shadow: 0 0 12px rgba(255, 255, 255, 0.3);
      }

      .restart-message {
        font-family: "Courier New", Courier, monospace;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.85);
        text-align: center;
        margin-top: 8px;
        text-shadow: 0 0 12px rgba(255, 255, 255, 0.3);
      }

      .instructions {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        color: rgba(255, 255, 255, 0.6);
        font-size: 12px;
        font-family: "Courier New", Courier, monospace;
        text-align: center;
        padding: 8px 16px;
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
      }
    </style>
  </head>
  <body>
    <div class="crt">
      <canvas id="stars" class="stars" width="1" height="1" aria-hidden="true"></canvas>

      <div class="game-container">
        <div class="game-ui">
          <a href="../" class="back-link">←</a>
          <div class="score" id="score">0</div>
          <div class="highscores" id="highscores"></div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div class="game-over" id="gameOver">
          <div class="game-over-box">
            <div class="game-over-title">game over</div>
            <div class="game-over-score">Score: <span id="finalScore">0</span></div>
            <div class="restart-message">Press jump to play again</div>
          </div>
        </div>

        <div class="instructions" id="instructions">
          Tap or press SPACE/↑ to jump
        </div>
      </div>
    </div>

    <script src="../script.js?v=1"></script>
    <script>
      (function() {
      // Game state
      const canvas = document.getElementById("gameCanvas");
      if (!canvas) {
        console.error("Canvas element not found!");
        return;
      }
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        console.error("Could not get 2d context!");
        return;
      }
      let gameState = "playing"; // playing, gameOver
      let score = 0;
      let gameSpeed = 4;
      let frameCount = 0;

      // Highscore management
      function getHighscores() {
        const stored = localStorage.getItem("teddyHighscores");
        return stored ? JSON.parse(stored) : [];
      }

      function saveHighscore(newScore) {
        let highscores = getHighscores();
        highscores.push(newScore);
        highscores.sort((a, b) => b - a); // Sort descending
        highscores = highscores.slice(0, 5); // Keep top 5
        localStorage.setItem("teddyHighscores", JSON.stringify(highscores));
        return highscores;
      }

      function updateHighscoresDisplay() {
        const highscores = getHighscores();
        const container = document.getElementById("highscores");
        container.innerHTML = "";
        
        if (highscores.length === 0) {
          return;
        }

        highscores.forEach((score, index) => {
          const item = document.createElement("div");
          item.className = "highscore-item";
          item.textContent = `${index + 1}. ${score}`;
          container.appendChild(item);
        });
      }

      // Set canvas size
      function resizeCanvas() {
        const maxWidth = Math.min(1200, window.innerWidth - 40);
        const maxHeight = Math.min(600, window.innerHeight - 40);
        canvas.width = maxWidth;
        canvas.height = maxHeight;
        // Update ground position when resizing
        if (ground.y > 0) {
          ground.y = canvas.height - ground.height;
          teddy.groundY = canvas.height - ground.height - teddy.height;
          if (teddy.grounded) {
            teddy.y = teddy.groundY;
          }
        }
      }
      window.addEventListener("resize", resizeCanvas);

      // Teddy bear (player)
      const teddy = {
        x: 80,
        y: 0,
        width: 50,
        height: 50,
        velocityY: 0,
        jumpPower: -12,
        gravity: 0.6,
        grounded: false,
        groundY: 0,
      };

      // Ground
      const ground = {
        height: 40,
        y: 0,
      };

      // Obstacles (soft play blocks) - smaller size
      const obstacles = [];
      const obstacleTypes = [
        { type: "cube", width: 35, height: 35, color: [255, 60, 60] }, // red cube
        { type: "cube", width: 35, height: 35, color: [60, 150, 255] }, // blue cube
        { type: "cube", width: 35, height: 35, color: [255, 220, 60] }, // yellow cube
        { type: "cube", width: 35, height: 35, color: [60, 200, 80] }, // green cube
        { type: "cylinder", width: 32, height: 40, color: [255, 60, 60] }, // red cylinder
        { type: "cylinder", width: 32, height: 40, color: [60, 150, 255] }, // blue cylinder
        { type: "rect", width: 40, height: 30, color: [255, 220, 60] }, // yellow rect
        { type: "rect", width: 40, height: 30, color: [60, 200, 80] }, // green rect
        { type: "triangle", width: 35, height: 35, color: [255, 60, 60] }, // red triangle
        { type: "disc", width: 40, height: 25, color: [60, 150, 255] }, // blue disc
      ];


      // Initialize
      function init() {
        resizeCanvas();
        teddy.groundY = canvas.height - ground.height - teddy.height;
        teddy.y = teddy.groundY;
        ground.y = canvas.height - ground.height;
        obstacles.length = 0;
        score = 0;
        gameSpeed = 4;
        frameCount = 0;
        gameState = "playing";
        document.getElementById("gameOver").classList.remove("active");
        document.getElementById("instructions").style.display = "block";
        updateHighscoresDisplay();
      }

      // Draw teddy bear (pixel art style)
      function drawTeddy() {
        ctx.save();
        ctx.imageSmoothingEnabled = false; // Pixel art style
        
        const x = teddy.x;
        const y = teddy.y;
        const w = teddy.width;
        const h = teddy.height;
        const pixelSize = 3; // Size of each "pixel"
        
        // Helper to draw a pixel block
        function pixel(px, py, color) {
          ctx.fillStyle = color;
          ctx.fillRect(x + px * pixelSize, y + py * pixelSize, pixelSize, pixelSize);
        }
        
        // Body (brown)
        const brown = "#A67C52";
        const lightBrown = "#D4A574";
        const white = "#F5F5DC";
        const black = "#1A1A1A";
        const pink = "#FFB6C1";
        
        // Body outline and fill
        for (let py = 8; py < 14; py++) {
          for (let px = 4; px < 13; px++) {
            if (py === 8 || py === 13 || px === 4 || px === 12) {
              pixel(px, py, "#8B5A3C"); // Darker brown outline
            } else {
              pixel(px, py, brown);
            }
          }
        }
        
        // Head
        for (let py = 0; py < 8; py++) {
          for (let px = 3; px < 14; px++) {
            if (py === 0 || py === 7 || px === 3 || px === 13) {
              pixel(px, py, "#8B5A3C"); // Outline
            } else {
              pixel(px, py, brown);
            }
          }
        }
        
        // White snout area
        for (let py = 3; py < 6; py++) {
          for (let px = 6; px < 11; px++) {
            pixel(px, py, white);
          }
        }
        
        // Black square eyes
        pixel(6, 2, black);
        pixel(7, 2, black);
        pixel(9, 2, black);
        pixel(10, 2, black);
        
        // Black square nose
        pixel(7, 4, black);
        pixel(8, 4, black);
        pixel(9, 4, black);
        pixel(7, 5, black);
        pixel(8, 5, black);
        pixel(9, 5, black);
        
        // Pink blush squares on cheeks
        pixel(4, 4, pink);
        pixel(5, 4, pink);
        pixel(11, 4, pink);
        pixel(12, 4, pink);
        
        // Ears (left)
        for (let py = 1; py < 4; py++) {
          for (let px = 1; px < 4; px++) {
            if (py === 1 || px === 1 || px === 3) {
              pixel(px, py, "#8B5A3C");
            } else {
              pixel(px, py, brown);
            }
          }
        }
        // Inner ear (left)
        pixel(2, 2, lightBrown);
        
        // Ears (right)
        for (let py = 1; py < 4; py++) {
          for (let px = 13; px < 16; px++) {
            if (py === 1 || px === 13 || px === 15) {
              pixel(px, py, "#8B5A3C");
            } else {
              pixel(px, py, brown);
            }
          }
        }
        // Inner ear (right)
        pixel(14, 2, lightBrown);
        
        // Arms (left)
        for (let py = 9; py < 13; py++) {
          for (let px = 1; px < 4; px++) {
            if (py === 9 || px === 1 || px === 3) {
              pixel(px, py, "#8B5A3C");
            } else {
              pixel(px, py, brown);
            }
          }
        }
        // Paw pad (left)
        pixel(2, 11, lightBrown);
        
        // Arms (right)
        for (let py = 9; py < 13; py++) {
          for (let px = 13; px < 16; px++) {
            if (py === 9 || px === 13 || px === 15) {
              pixel(px, py, "#8B5A3C");
            } else {
              pixel(px, py, brown);
            }
          }
        }
        // Paw pad (right)
        pixel(14, 11, lightBrown);
        
        // Legs (left)
        for (let py = 14; py < 17; py++) {
          for (let px = 5; px < 8; px++) {
            if (py === 14 || px === 5 || px === 7) {
              pixel(px, py, "#8B5A3C");
            } else {
              pixel(px, py, brown);
            }
          }
        }
        // Paw pad (left foot)
        pixel(6, 15, lightBrown);
        
        // Legs (right)
        for (let py = 14; py < 17; py++) {
          for (let px = 9; px < 12; px++) {
            if (py === 14 || px === 9 || px === 11) {
              pixel(px, py, "#8B5A3C");
            } else {
              pixel(px, py, brown);
            }
          }
        }
        // Paw pad (right foot)
        pixel(10, 15, lightBrown);
        
        ctx.imageSmoothingEnabled = true; // Restore smoothing
        ctx.restore();
      }

      // Draw obstacle (soft play block) - SIMPLIFIED for maximum visibility
      function drawObstacle(obs) {
        const [r, g, b] = obs.color;
        const x = obs.x;
        const y = obs.y;
        const w = obs.width;
        const h = obs.height;

        // WHITE OUTLINE for maximum visibility (thick)
        ctx.strokeStyle = "#FFFFFF";
        ctx.lineWidth = 6;
        ctx.strokeRect(x - 4, y - 4, w + 8, h + 8);
        
        // Bright fill (saturated colors)
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.fillRect(x, y, w, h);
        
        // Add inner highlight for depth
        ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
        ctx.fillRect(x, y, w, h / 3);
        
        // Simple shape indicator based on type
        ctx.save();
        ctx.translate(x + w / 2, y + h / 2);

        // Simple shape indicators (optional - just for variety)
        if (obs.type === "cylinder" || obs.type === "disc") {
          // Draw rounded top/bottom for cylinders and discs
          ctx.fillStyle = `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`;
          ctx.beginPath();
          ctx.arc(0, -h / 2 + 5, 8, 0, Math.PI * 2);
          ctx.fill();
        } else if (obs.type === "triangle") {
          // Draw triangle indicator
          ctx.fillStyle = `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`;
          ctx.beginPath();
          ctx.moveTo(0, -h / 2 + 5);
          ctx.lineTo(-8, -h / 2 + 15);
          ctx.lineTo(8, -h / 2 + 15);
          ctx.closePath();
          ctx.fill();
        }

        ctx.restore();
      }

      // Draw ground (white-ish floor)
      function drawGround() {
        const floorY = ground.y;
        const floorHeight = canvas.height - floorY;
        
        // White-ish floor
        const floorGrad = ctx.createLinearGradient(0, floorY, 0, canvas.height);
        floorGrad.addColorStop(0, "#F5F5F5");
        floorGrad.addColorStop(0.3, "#E8E8E8");
        floorGrad.addColorStop(1, "#DDDDDD");
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0, floorY, canvas.width, floorHeight);
        
        // Subtle floor shadow at top edge
        const shadowGrad = ctx.createLinearGradient(0, floorY - 5, 0, floorY);
        shadowGrad.addColorStop(0, "rgba(0, 0, 0, 0.1)");
        shadowGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = shadowGrad;
        ctx.fillRect(0, floorY - 5, canvas.width, 5);
      }

      // Draw background (Matrix green/black theme)
      function drawBackground() {
        const floorY = ground.y;

        // Matrix green/black background (above floor)
        const bgGrad = ctx.createLinearGradient(0, 0, 0, floorY);
        bgGrad.addColorStop(0, "#000000");
        bgGrad.addColorStop(0.5, "#001100");
        bgGrad.addColorStop(1, "#000000");
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, canvas.width, floorY);
        
        // Subtle Matrix green tint overlay
        const greenOverlay = ctx.createLinearGradient(0, 0, canvas.width, floorY);
        greenOverlay.addColorStop(0, "rgba(0, 255, 65, 0.02)");
        greenOverlay.addColorStop(0.5, "rgba(0, 204, 51, 0.015)");
        greenOverlay.addColorStop(1, "rgba(0, 255, 65, 0.02)");
        ctx.fillStyle = greenOverlay;
        ctx.fillRect(0, 0, canvas.width, floorY);
      }

      // Update game
      function update() {
        if (gameState !== "playing") return;

        frameCount++;
        score = Math.floor(frameCount / 10);

        // Increase speed gradually
        gameSpeed = 4 + score / 200;

        // Update teddy bear physics
        teddy.velocityY += teddy.gravity;
        teddy.y += teddy.velocityY;

        // Ground collision
        if (teddy.y >= teddy.groundY) {
          teddy.y = teddy.groundY;
          teddy.velocityY = 0;
          teddy.grounded = true;
        } else {
          teddy.grounded = false;
        }

        // Spawn obstacles (first one at frame 60, then every 90-120 frames based on score)
        const spawnInterval = Math.max(90, 150 - Math.floor(score / 30));
        if (frameCount === 60 || (frameCount > 60 && (frameCount - 60) % spawnInterval === 0)) {
          const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
          const obsY = teddy.groundY + teddy.height - type.height;
          obstacles.push({
            x: canvas.width,
            y: obsY,
            width: type.width,
            height: type.height,
            color: type.color,
            type: type.type,
          });
          // Debug: log obstacle spawn
          console.log("Obstacle spawned:", { x: canvas.width, y: obsY, width: type.width, height: type.height, groundY: teddy.groundY, teddyY: teddy.y });
        }

        // Update obstacles
        obstacles.forEach((obs) => {
          obs.x -= gameSpeed;
        });

        // Remove off-screen obstacles
        while (obstacles.length > 0 && obstacles[0].x + obstacles[0].width < 0) {
          obstacles.shift();
        }

        // Collision detection
        obstacles.forEach((obs) => {
          if (
            teddy.x < obs.x + obs.width &&
            teddy.x + teddy.width > obs.x &&
            teddy.y < obs.y + obs.height &&
            teddy.y + teddy.height > obs.y
          ) {
            gameOver();
          }
        });

        // Update score display
        document.getElementById("score").textContent = score;
      }

      // Jump
      function jump() {
        if (teddy.grounded && gameState === "playing") {
          teddy.velocityY = teddy.jumpPower;
          teddy.grounded = false;
        }
      }

      // Game over
      function gameOver() {
        gameState = "gameOver";
        document.getElementById("finalScore").textContent = score;
        document.getElementById("gameOver").classList.add("active");
        document.getElementById("instructions").style.display = "none";
        
        // Save and update highscores
        saveHighscore(score);
        updateHighscoresDisplay();
      }

      // Restart
      function restartGame() {
        init();
      }

      // Expose restartGame globally for button click
      window.restartGame = restartGame;

      // Render
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawBackground();
        drawGround();
        drawTeddy();
        obstacles.forEach(drawObstacle);
      }

      // Game loop
      function gameLoop() {
        update();
        render();
        requestAnimationFrame(gameLoop);
      }

      // Controls
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" || e.key === "ArrowUp") {
          e.preventDefault();
          if (gameState === "gameOver") {
            restartGame();
          } else {
            jump();
          }
        }
      });

      // Touch controls - make the whole game area tappable
      const gameContainer = document.querySelector(".game-container");
      let touchStartY = 0;
      
      gameContainer.addEventListener("touchstart", (e) => {
        e.preventDefault();
        touchStartY = e.touches[0].clientY;
        if (gameState === "gameOver") {
          restartGame();
        } else {
          jump();
        }
      }, { passive: false });

      // Also allow tap anywhere on the canvas
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (gameState === "gameOver") {
          restartGame();
        } else {
          jump();
        }
      }, { passive: false });

      // Start game when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          init();
          gameLoop();
        });
      } else {
        init();
        gameLoop();
      }
      })(); // End IIFE
    </script>
  </body>
</html>

